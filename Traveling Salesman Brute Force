#uses embeded tuples for points, runs every permutation when its created and does not have a list of permutations(size x!).
#without uses lists of size x! this program uses much less memory and is only bottle necked by cpu power.
from tkinter import *
import time
import random
import math as m
num2 =5
dots=""
perms =[]
num5=800
num7= 1000
points= []
tempdistance= []
distances = []
tempperms= []
tempdistance = []
d1=0
d2=0
bestpath = []
worstpath = []
a=0
b=10**12
c=0



##makes random points
for z in range(0,num2):    
    x =random.randint(0,num5)
    y= random.randint(0,num5)
    points.append((x,y))
    

##finds every distance
for w in range(0,num2):
    for p in range(0,num2):
        tempdistance.append(m.sqrt((points[p][0]-points[w][0])**2+(points[p][1]-points[w][1])**2))
    distances.append(tempdistance)
    tempdistance= []


##permutation function
for t in range(0,num2):
        dots = str(dots)+str(t)
def perm2(lst):
	if len(lst) == 0:
		yield []
	elif len(lst) == 1:
		yield lst
	else:
		for i in range(len(lst)):
			x = lst[i]
			xs = lst[:i] + lst[i+1:]
			for p in perm2(xs):
				yield [x] + p
                
data = list(dots)



for p in perm2(data):    
    p.append(p[0])
    tempperms = p
    #finds the distance of the permutation with appending it to a list.
    for s in range(0,len(tempperms)-1):
        
        p1 = int(tempperms[s])
        p2 = int(tempperms[s+1])
        tempdistance.append(distances[p1][p2])
    ## simple if staments to remember the worst and best distances/paths without list.   
    if sum(tempdistance)<b:
            b=sum(tempdistance)
            bestpath = tempperms
    if sum(tempdistance)>c:
            c=sum(tempdistance)
            worstpath = tempperms
    tempdistance = []

print("Most Efficient Route",b,bestpath)
print("Most Inefficient Route",c,worstpath)

##uses tkinter to display that paths.
class MyFrame(Frame):
    def __init__(self):
            Frame.__init__(self)
            self.myCanvas = Canvas(width=num5,height=num5,bg="black")
            self.myCanvas.grid()
            for z in range(0, num2):
                    d1 = int(bestpath[z])
                    d2 = int(bestpath[z+1])
                    self.myCanvas.create_line(points[d1][0],points[d1][1],points[d2][0],points[d2][1],fill="green")
            for h in range(0,num2):
                    d1 = int(worstpath[h])
                    d2 = int(worstpath[h+1])
                    self.myCanvas.create_line(points[d1][0],points[d1][1],points[d2][0],points[d2][1],fill="red")
frame02=MyFrame()
frame02.mainloop()
